## 7 定义函数的方式

1. 函数声明（存在函数声明提升，所以可以在函数声明之前调用函数）
2. 函数表达式（调用必须在声明之前）

**不要用下面的方式去定义一个函数**

不同的浏览器对此解析不同，有的两个都声明了，有的只声明了a函数

``` javascript

if (true) {
  function a () {
    return 'a'
  }
} else {
  function b () {
    return 'b'
  }
}

```


**如果想根据不同的条件声明函数可以用函数表达式**

``` javascript
var fn = null

if (true) {
  fn = function () {
    return 'a'
  }
} else {
  fn = function () {
    return 'b'
  }
}

```

## 7.1 递归

``` javascript
function recursion (num) {
  if (num === 1) {
    return 1
  } else {
    return num * recursion(num - 1)        
  }
}

```
以上定义了一个递归求阶乘的函数，如果我们用下面这种使用方式会怎么样呢？

``` javascript
var fn = recursion
recursion = null

fn(2) // 这个时候就报错了，因为recursion函数内部，调用了recursion本身，但是recurtion已经被赋值为了null。


```
**怎么办？使用`arguments.callee`**

他是一个当前正在执行的函数的引用

``` javascript
function recursion (num) {
  if (num === 1) {
    return 1
  } else {
    return num * arguments.callee(num - 1)        
  }
}

var fn = recursion

recursion = null

fn(3) // 6

```
缺陷是严格模式下不允许这样用

**还有别的方式**

``` javascript

var recursion = function f (num) {
  if (num === 1) {
    return 1
  } else {
    return num * f(num - 1)
  }
}

var fn = recursion
recursion = null
fn(3) // 2
```

**函数表达式依旧可以给函数取名字**

## 7.2 闭包

> 一个能够访问另一个函数作用域中变量的函数。

``` javascript
var property = function (key) {
  return function (obj) {
    return obj[key]    
  }
}

var length = property('length')

```

以上就是一个经典的闭包，需要注意的是闭包会产生比普通函数更多的内存，所以需要慎用。


## 7.2.1 闭包与变量

> 闭包只能取得包含函数中任何变量的最后一个值


``` javascript
var fn = function () {
  var arrFn = []
  var i = 0
  
  for (; i < 10; i++) {
    arrFn[i] = function () {
      return i
    }
  }
  
  return arrFn
}

var fns = fn()
```

我们以为创建出来的函数数组`fns`会输出0， 1， 2....，但是实际上只会得到10，因为闭包只能拿到包含函数中所有变量的最后值。

**i在循环结束的时候已经变成了10**，故所有的函数执行都只能得到10


**如果想得到对应的输出，我们可以用其他的闭包方式,例如**


``` javascript
var fn = function () {
  var arrFn = []
  var i = 0
  
  for (; i < 10; i++) {
    arrFn[i] = (function (num) {
      return function () {
        return num
      }
    })(i)
  }
  
  return arrFn
}

var fns = fn()


```
**这个时候每个立即执行函数的都有自己的执行环境，而fns数组中函数的所形成的闭包自然也可以得到自己的唯一的num值了**


## 7.2.2 关于this对象

> 关于闭包能够访问另一个函数的变量，有两个比较特殊`this`, `arguments`

``` javascript
var name = 'the window'
var obj = {
  name: 'the obj',
  showName: function () {
    return function () {
      return this.name // 注意这里
    }
  }
}

obj.showName()() // the window
```

**为毛得到了`the window`**,记住`this`和`arguments`两个值比较特殊就可以，如果没有手动将`另一个函数的this和arguments赋值`，其得到的还是动态运行的结果，我们看下面的例子就可以明白


``` javascript
var name = 'the window'
var obj = {
  name: 'the obj',
  showName: function () {
    var thatArguments = arguments
    var that = this
    return function () {
      console.log(thatArguments)
      console.log(that.name)
      console.log(this.name) 
    }
  }
}

obj.showName()() // the window


```

## 7.2.3  内存泄漏

> 
